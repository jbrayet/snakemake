
from snakemake.utils import report
from urllib.request import pathname2url

configfile: "/bioinfo/users/jbrayet/Bureau/snakemake/pipeline_rna/config.yaml"

#include: "../snakemake_rules/trimGalore_rule"
include: "../snakemake_rules/fastqc_rule"

if config["aligment"]["TOOL"] == "TOPHAT2":
    include: "../snakemake_rules/samtools_merge_rule"
    if config["picard"]["MARKDUP"] != "yes":
        include: "../snakemake_rules/tophat2_rule"
    else:
        include: "../snakemake_rules/tophat2_and_markdup_rule"
        include: "../snakemake_rules/picard_markdup_rule"

if config["aligment"]["TOOL"] == "STAR":
    include: "../snakemake_rules/star_indexes_rule"
    include: "../snakemake_rules/samtools_sam_to_bam_rule"
    include: "../snakemake_rules/star_rule"

    if config["picard"]["MARKDUP"] != "yes":
        include: "../snakemake_rules/samtools_sort_rule"
    else:
        include: "../snakemake_rules/samtools_sort_and_markdup_rule"
        include: "../snakemake_rules/picard_markdup_rule"

include: "../snakemake_rules/samtools_index_rule"
include: "../snakemake_rules/samtools_flagstat_rule"
include: "../snakemake_rules/samtools_bam_to_sam_rule"
include: "../snakemake_rules/htseq_rule"
include: "../snakemake_rules/gatk_rule"
include: "../snakemake_rules/reformat_coverage_rule"
include: "../snakemake_rules/curie_report_rule"
include: "../snakemake_rules/graph_rule"

workdir: config["general_path"]["INPUT_PATH"]
output_path=config["general_path"]["OUTPUT_PATH"]

#graph=expand(output_path+"/graph.svg")

#trimming=expand((output_path+"/{sample}/{sample}.R1.fastq.gz", output_path+"/{sample}/{sample}.R2.fastq.gz"), sample=config["samples"])

qc=expand((output_path+"/{sample}/{sample}.{group}_fastqc.zip", output_path+"/{sample}/{sample}.{group}_fastqc.html"), sample=config["samples"], group=config["group"])

if config["aligment"]["TOOL"] == "TOPHAT2":
    if config["picard"]["MARKDUP"] != "yes":

        tophat2_align=expand((output_path+"/{sample}/{sample}.mapped.bam", output_path+"/{sample}/{sample}.unmapped.bam", output_path+"/{sample}/{sample}.deletions.bed", output_path+"/{sample}/{sample}.insertions.bed", output_path+"/{sample}/{sample}.junctions.bed"), sample=config["samples"])

    else:

        tophat2_align_and_markdup=expand((output_path+"/{sample}/{sample}.mapped.markdup.bam", output_path+"/{sample}/{sample}.unmapped.bam", output_path+"/{sample}/{sample}.deletions.bed", output_path+"/{sample}/{sample}.insertions.bed", output_path+"/{sample}/{sample}.junctions.bed"), sample=config["samples"])

        markdup=expand((output_path+"/{sample}/{sample}.duplicates.bam", output_path+"/{sample}/{sample}.metrics", output_path+"/{sample}/{sample}.mapped.bam"), sample=config["samples"], group=config["group"])

    merge=expand(output_path+"/{sample}/{sample}.bam", sample=config["samples"])

if config["aligment"]["TOOL"] == "STAR":
    star_indexes=expand(("{annotation_path}/chrLength.txt", "{annotation_path}/chrName.txt", "{annotation_path}/chrStart.txt", "{annotation_path}/Genome", "{annotation_path}/genomeParameters.txt", "{annotation_path}/SA", "{annotation_path}/SAindex"), annotation_path=config["star"]["GENOME_DIR"])

    star_align=expand((output_path+"/{sample}/{sample}_Aligned.out.sam", output_path+"/{sample}/{sample}_ReadsPerGene.out.tab", output_path+"/{sample}/{sample}_SJ.out.tab"), sample=config["samples"])
    bam_file=expand(output_path+"/{sample}/{sample}.tmp.bam", sample=config["samples"])

    if config["picard"]["MARKDUP"] != "yes":

        sort_bam_file=expand((output_path+"/{sample}/{sample}.bam", output_path+"/{sample}/{sample}.mapped.bam"), sample=config["samples"])

    else:

        sort_bam_file=expand((output_path+"/{sample}/{sample}.bam", output_path+"/{sample}/{sample}.mapped.markdup.bam"), sample=config["samples"])
        markdup=expand((output_path+"/{sample}/{sample}.duplicates.bam", output_path+"/{sample}/{sample}.metrics", output_path+"/{sample}/{sample}.mapped.bam"), sample=config["samples"], group=config["group"])

sam_file=expand(output_path+"/{sample}/{sample}.sam", sample=config["samples"])

htseq=expand(output_path+"/{sample}/{sample}.htseq", sample=config["samples"])

index=expand(output_path+"/{sample}/{sample}.bam.bai", sample=config["samples"])

flagstat=expand(output_path+"/{sample}/{sample}.stats.txt", sample=config["samples"])

coverage=expand(output_path+"/{sample}/{sample}_coverage.txt", sample=config["samples"])

reformat_coverage=expand(output_path+"/{sample}/{sample}.coverage.stats.txt", sample=config["samples"])

#samples_biosamples=[]
#dict_samples=config["samples"]
#dict_biosample=config["biosamples"]

#for key, value in dict_samples.items():
#    samples_biosamples.append(str(key)+"-"+str(dict_biosample[key]))

#print(samples_biosamples)

curie_report=expand(output_path+"/{sample}/{sample}--NGS-RunReport.pdf", sample=config["samples"])

#report=expand(output_path+"/report.html")

rule all:
    input:
#        star_indexes,
#        trimming,
#        qc,
#        tophat2_align,
#        tophat2_align_and_markdup,
#        star_align,
#        bam_file,
#        markdup,
#        merge,
#        sam_file,
#        htseq,
#        index,
#        flagstat,
#        coverage,
#        reformat_coverage,
#        curie_report,
#        graph,
#        report
        config["general_path"]["OUTPUT_PATH"]+"/report.html"
    params:
        cluster="-q batch -N snakemake_rna_pipeline -l nodes=1:ppn=1,mem=1Gb",
        input_path=config["general_path"]["INPUT_PATH"]
    shell: 
        "rm -f {params.input_path}/snakemake_*"


rule report:
    input:
        reportTable=curie_report,
#        graph=graph
        countTable=htseq
    output: 
        html=config["general_path"]["OUTPUT_PATH"]+"/report.html"
    params:
        cluster="-q batch -N snakemake_report_rna_pipeline -l nodes=1:ppn=1,mem=1Gb"
    run:
#        Pipeline graph: graph_

        samples=len(config["samples"])

        report("""
        ================================
        An example RNA analysis workflow
        ================================

        Number of sample(s): {samples}
       
        One report is available for each sample (see reportTable_ table). 

        HTSeq files (see countTable_ table).

        """, output.html, metadata="Jocelyn Brayet (jocelyn.brayet@curie.fr)", **input)

